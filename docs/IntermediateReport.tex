\documentclass[times,9pt,article]{llncs}
\usepackage{times}
\usepackage{makeidx}

\begin{document}
\title{Peer-to-Peer File System}
\institute{Peer-to-Peer Systems and Overlay Networks \\
Masters Degree in Telecommunications and Informatics Engineering \\
Instituto Superior T\'ecnico}

\author{Group Number 2 \\
Jo\~ao Granchinho n.54766 mail@ist.utl.pt \\
Pedro Torres  n.63506 mail@ist.utl.pt \\
Rodrigo Bruno n.67074 rodrigo.bruno@ist.utl.pt}
\maketitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 1:  Introduction 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
In this document we will be describing our solution and explaining how we intend
to fulfill the challenge proposed within the project specification.

We will start by explaining why we chose Kademlia as our DHT for this project.
Next we detail the protocol that we will be using for implementing a distributed
file system on top of a Kademlia peer-to-peer network overlay.

Conclusion?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 2:  Kademlia 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Kademlia}

As one of the studied DHT and one of the proposed DHT implementations for the 
project, we decided to use TomP2P, a Kademlia's protocol implementation.

This decision was mainly motivated by the fact that Kademlia was designed to be
used by file sharing applications and therefore provides some nice features that
will be very helpful for our file system's implementation. 

We will now describe some of the Kademlia features and explain how we will take 
advantage of them. 

\subsection{Iterative Parallel Search}
Kademlia and therefore TomP2P uses iterative parallel search. Two main benefits
from this search procedure are: 

\begin{itemize}
\item generated/received information is useful for refreshing the k-buckets;
\item parallel queries prevents waiting for timeouts to detect failed nodes and 
allows the fastest nodes (the ones with the lowest RTT) to be used. 
\end{itemize} 

As that being, using Kademlia we will be able to provide a better quality of
service by providing faster search and reduced maintenance traffic.

\subsection{Key-Republishing}
Key-Republishing is a very interesting feature provided by Kademlia. This feature
is important to ensure the persistence of the key-value pairs.

Two phenomena may jeopardize the key-value pairs: a node responsible for the pair
leaving the network and a node with a closer id (closer to the key) joining the
network. 

TomP2P takes care of both scenarios using Indirect Replication (name used in the
TomP2P's documentation). The activation of this mechanism will ensure that nodes
react when one of the situations above described happen. 

This Key-Republishing will be very useful since it will help implementing file
replication algorithm that is one of the requirements for our file system.   

\subsection{Caching (direct replication)}

Another interesting feature is caching. Caching enables the replication of 
key-value pairs along the search path. If we take in consideration that our 
distance metric (exclusive or) is unidirectional, this means that searches 
from different origins will converge into a search path. As that being, using
caching, Kademlia is able to reduce the burden on nodes holding popular content.

Within the context of our project, this functionality can be used to speed up
the statistical information delivery. Since this information will be calculated
periodically, its contents can be cached (temporarily) to provide lower load on
the node holding this information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 3:  P2P FS Management 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Gossip}

With the purpose of monitoring P2P FS and provide high level information to the 
users, we will use a Gossip protocol, where the nodes in each bucket will have 
knowledge of the information of each other. And upon information request, which
 was deployed in parallel, a chain event will be unleashed in which every node
 will share its bucket's information.\\
Each node will store a key value pair with metadata with the number of users 
mounted and the list of files per user, and upon request the node will respond 
by consulting this metadata and doing some simple math. After convergence of the
 Gossip protocol it will be presented to the requester the final set of 
 information.\\
The algorithm for each type of informations is as follows:
\begin{itemize}
\item To obtain the number of users each node sums the value in the metadata and
 divides by the replication factor.
\item To obtain the number of active users each node will respond with the number
 of users that have more than 0 users mounted.
\end{itemize} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 4:  File System Metadata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{File System Metadata}

In P2PFS there are two types of entities: users and files . Entities representing
users will use the user name as key (hash of the user name) and the value will 
be the number of active mount points. 

Files will represent both normal files and directories. Both entities will have 
a number of parts and a summary (checksum). For files, the actual file content
is stored; for directories, the available files within will be stored. Only the
first part of each file needs to store the number of file parts. Note that 
TomP2P is able to store multiple values for each key (given an auxiliary key).   

Files stored on P2PFS will have specially constructed ids (that will be used to
generate keys) obtained by using the following information: owner user, complete 
path, file type and part number.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 5:  Load Balancing/Security
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Load Balancing/Security}

Load balancing and security are two of our project's requirements. This two 
requirements can be met by splitting files into multiple nodes:
\begin{itemize}
\item load balancing will be achieved by using a hash function that will take
an id and output a new key that will be mapped into a different node. This way,
when a file gets bigger that a certain amount of kBs, the file gets split and
therefore, the load for accessing the file will be shared;
\item security concerns will also be met by file division since the files will
tend to be divided in several machines. Therefore, no node will host all file
parts.
\end{itemize} 

The used criteria for splitting a file is a fixed size limit. When the last part
of a file gets bigger than the limit, that file gets split. By using a not so high
value we facilitate the distribution of load among all nodes. However this value
is application dependent and for developing purposes we will start by using a
1Mb part size limit.   

\section{Other Design Decisions}
\begin{itemize}
\item Falar dos clientes so passarem a guardar fichieros passado algum tempo;
\item Cache local do file system. Leituras periodicas da metadata. Atrasar escritas.
\end{itemize}

\section{Future Enhancements}
Se houver espa√ßo.

\end{document}
